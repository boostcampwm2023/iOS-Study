### Q1. 옵셔널에 대해서 간략하게 설명해 주실 수 있을까요?
옵셔널은 스위프트에서 타입 안정성을 높이기 위해서 만든 열거형 타입입니다. 
그래서 열거형 안에 nil 케이스라는 게 있는데 이 nil 케이스로 값이 없음을 나타낼 수 있고 이 nil인 상황일 때 옵셔널 바인딩, nil 병합 연산자 같은 걸 이용해서 안전하게 구현을 할 수가 있습니다. 
옵셔널을 학습을 할 때 옵셔널 코드를 가볍게 살펴본 경험이 있는데 옵셔널의 비교 연산자 구현이 되게 인상적이었던 것 같아요.
옵셔널 타입이랑 옵셔널이 아닌 타입을 비교하기 위해서 같다, 같지 않다 이런 비교 연산자를 하나하나 구현한 점이 인상적이었고, 이런 추가 구현 때문에 개발자가 불편하지 않으면서 언어의 안정성을 높이게끔 구현을 했다고 해서 인상적이었습니다.

### Q2. 혹시 비교 연산자가 많은 게 인상 깊다고 하셨었는데 대표적으로 떠오르는 예시 한두 가지만 얘기해 줄 수 있나요?
예를 들어서 저희 같은 타입일 때는 Equal 프로토콜을 이용해서 갖다 연산자를 사용을 할 수가 있잖아요. 
네 말씀드렸듯이 옵셔널은 이원 타입이고 옵셔널이 아닌 거는 이런 타입이 아니기 때문에 같은 타입이 아니니까 이제 그냥 이쿼터블을 이용해서는 비교를 할 수가 없어요.
그래서 이거를 해소하기 위해서 직접 가짜 연산자 그다음에 같지 않다 그다음에 대소 비교를 하나하나 구현을 해서 네 이렇게 하나하나 구현을 한 점이 인상 깊었습니다.

### Q3. 실제로 옵셔널을 안전하게 해제하기 위한 방법이 뭐가 있는지 간단하게 설명해 주실 수 있나요?
옵셔널 바인딩 그다음에 nil 병합 연산자 물음표 2개를 사용하는 nil 병합 연산자 이렇게 두 가지를 사용을 할 수가 있습니다. 
그래서 if let, guard let을 이용해서 nil이 있는 경우 없는 경우를 나눠서 로직을 수행을 할 수가 있고, 병합 연산자는 nil이 아닌 경우에 기본 값을 설정을 해서 nil 처리를 할 수 있게끔 이렇게 처리를 할 수 있습니다.

### Q4. 그럼 if let과 guard let의 차이점을 설명해 주실 수 있을까요?
if let은 옵셔널 값이 nil이 아닐 때 if문 안의 로직을 수행하는 의미이고, guard let은 옵셔널 값이 있을 때 가드문 이후에 로직을 수행한다는 의미가 있습니다. 
그래서 가드문은 early exit 의미를 가지고 있어서 이게 nil이 아닐 때 이후 로직을 수행하지 않겠다라는 의미가 강합니다.

### Q5. forced 언래핑에 대해서도 아실 것으로 예상이 되는데, 혹시 이러한 forced 언래핑을 사용해야 하는 경우가 있을까요? 사용하신 경험이나요.
가장 대표적으로는 IBOutlet을 사용을 할 때 강제 언래핑이 들어가는 것 같습니다. 
스토리보드에서 IBOutlet으로 해서 연결을 할 때 기본적으로 강제 언래핑 객체로 이렇게 선언이 되는데, 그 이유가 제가 생각했을 때는 이 IBOutlet이 없으면 그냥 강제 종료가 되는 게 낫다라고 생각을 해서 이렇게 기본적으로 강제 언래핑으로 사용이 되는 것 같고요. 
저도 이런 흐름으로 강제 언래핑을 하는데, 기본값을 설정을 하거나 따로 로직을 처리할 게 아니라 강제 종료를 해서 디버깅을 빨리 하는 게 낫다라는 상황이 있으면 그때 강제 언래핑을 사용하려고 합니다.

### Q6. 실제 사용을 하신 적은 있으셨을까요?
예를 들어서 뷰 같은 경우에는 필수적으로 보여줘야 하는 뷰가 있으면 그 뷰는 옵셔널 타입보다는 강제 옵셔널 타입을 사용을 해서 이 뷰가 뭔가 잘못됐을 때 객체가 할당이 안 되거나 이렇게 잘못됐을 때 빠르게 디버깅하는 용도로 사용을 한 적이 있습니다.

### Q7. 클로저가 어떤건지 설명을 해 주실 수 있을까요?
클로저는 간단하게 말해서 실행 가능한 코드 블록을 의미합니다. 
스위프트에서는 익명 함수로서 역할을 많이 하는데, 스위프트에서는 함수가 1급 객체로 동작을 하기 때문에 익명 함수인 클로저도 자연스럽게 1급 객체로 동작을 합니다. 
따라서 파라미터나 반환 값으로 사용할 수 있다는 특징이 있습니다.
그리고 클로저는 참조 객체이기 때문에 강한 순환 참조를 주의를 해야 합니다. 
클로저는 외부 데이터를 참조 객체로 캡처를 해서 사용을 하기 때문에 객체랑 클로저 사이에 강한 순환 참조가 발생하지 않도록 weak나 unowned를 사용해서 약한 참조로 캡처할 수 있도록 해야 합니다.

### Q8. 그러면 클로저 내부에서 외부 인스턴스를 참조하고 있을 때 무조건 weak self를 사용하는 게 맞는 걸까요?
클로저는 캡처하는 타입이 구조체인지 클래스인지, 즉 Value Semantic인지 Reference Semantic인지를 상관없이 무조건 참조 타입으로 캡처를 하기 때문에 구조체나 이런 것도 이제 weak self를 사용을 해서 강한 순환 참조를 없애야 합니다.

### Q9. 클로저에 여러 가지가 있는데, 혹시 escaping 클로저에 대해서 간단하게 설명해 주실 수 있으실까요?
escaping 클로저는 일반 클로저는 즉시 수행할 수 있는 클로저인 반면에 escaping 클로저는 지연 가능한 수행이 가능합니다. 
그래서 비동기 처리를 하거나 비동기 처리를 할 때, 비동기가 완료가 됐을 때 escaping 클로저를 수행을 해서 이 비동기 수행이 끝났다는 것을 알려줍니다.
그래서 네트워킹에서 네트워킹이 끝났을 때 escaping 클로저 수행을 해서 네트워킹이 끝났다는 것을 알리는 용도로 많이 사용을 합니다.

### Q10. 실제 네트워킹에서 escaping 클로저를 사용을 한다 하셨는데 그때 뭔가 느끼셨던 단점이 있으셨을까요?
escaping을 이용해서 비동기 로직을 작성을 하면 이 비동기 로직이 중첩이 되었을 때 이 코드 depth가 깊어지는 단점이 있습니다. 
그래서 코드 depth가 깊어지면 가독성이 떨어지고 이제 completionHandler escaping 클로저를 호출하는 것도 잊을 수 있기 때문에 이런 부분에서 불편함을 느낀 적이 있습니다.

### Q11. 혹시 그 점을 다른 방식으로 개선하는 작업도 해보셨나요?
이런 불편함이 있어서 async await이라는 스위프트 Concorrency 방식을 이용해서 개선을 한 적이 있습니다. 그래서 async await에서 사용을 하면 completionHandler에서 생겼던 이런 깊은 depth나 completionHandler 호출을 하지 않은 그런 단점들을 보완할 수가 있고 에러 throwing도 Swift 문법대로 할 수가 있어서 조금 더 자연스러운 스위프트 코드로 이렇게 작성을 할 수 있습니다.

### Q12. 오토 클로저에 대해서도 알고 있는지?
오토 클로저는 클로저로 감싸지 않아도 자동으로 클로저로서 동작을 할 수 있게끔 도와주는 키워드입니다. 네 그래서 많은 곳에서 사용한다고 알고 있는데 정확한 예시는 알지 못할 것 같습니다.

### Q13. ARC에 대해서 설명해 주시면 감사하겠습니다
ARC는 참조 객체의 레퍼런스 카운트를 추적을 해서 자동으로 메모리 관리를 해주는 기술입니다. 
컴파일 타임에 적절한 위치에 retain과 release 코드를 삽입을 해서, 참조 객체의 레퍼런스 카운트를 관리하고, 이 참조 객체의 레퍼런스 카운트가 0이 되면, 메모리에서 해제하는 원리로 메모리 관리를 하고 있습니다.
자동으로 메모리 관리를 해준다는 장점이 있지만, 이 ARC 때문에 메모리의 총 사용량이 증가하는 상황도 있습니다. 
예를 들어서, 메서드 안에서 크기가 큰 임시 객체를 생성하는 경우에, ARC는 메서드의 시작과 끝에 retain과 release 코드를 삽입을 합니다.
그래서 반복적으로 메소드 안에서 반복적으로 크기가 큰 임시 객체를 생성하게 되면은, 이 임시 객체들의 메모리가 해제되지 못하기 때문에, 메소드가 끝날 때까지 사용하는 메모리의 총 사용량이 증가하게 됩니다. 
그래서 이럴 때는 autoreleasepool이라는 Objective-c 문법을 이용해서 retain과 release 위치를 조정을 해서 이런 문제점을 해결할 수 있습니다.

### Q14. 그럼 스위프트에서는 왜 gc를 사용하지 않고 ARC를 채택하고 있을까요?
ARC의 가장 큰 장점은 컴파일 타임의 수행이 된다는 겁니다. 
가비지 컬렉터는 런타임의 객체들의 참조를 추적을 해서 회수를 하기 때문에, 해제가 안 되는 메모리는 없지만, 런타임 성능이 떨어진다는 단점이 있습니다.
반대로 스위프트의 ARC는 컴파일 타임에 수행이 되기 때문에, 런타임의 수행 능력이, 이 성능, 효율이 비교적 높다는 장점이 있습니다.

### Q15. 그럼 ARC의 단점은 없을까요?
ARC는 강한 순환 참조에 의해서 메모리 해제가 안 되는 상황이 있습니다. 
그래서 이럴 때는 weak나 unowned를 이용해서 강한 순환 참조를 해제를 한다면, 메모리 해제까지 안정적으로 가능합니다.

### Q16.  그럼 그 weak랑 unowned의 차이를 혹시 설명해 주실 수 있을까요?
weak랑 unowned 둘 다 약한 참조를 하는 방법인데, weak는 객체가 객체가 해지가 될 때 nil이 할당이 되기 때문에 이걸 weak를 사용을 할 때는 옵셔널이 필수라는 특징이 있습니다. 
반대로 unowned는 nil로 할당이 되지 않기 때문에 옵셔널이 필수가 아니지만, 이 할당된 위치에 접근을 하게 되면 런타임 에러가 발생한다는 단점이 있습니다.


### Q17. 그런 언어들을 사용하면 더 좋은 경우가 있을까요?
만약에 안정적으로 사용을 할 수 있다는 보장이 있으면 불필요한 옵셔널 바인딩이나 이런 옵셔널 처리가 필요하지 않다는 장점이 있습니다.

### Q18. 실제로 이 ARC 관련해서 직접 코드나 프로젝트에 녹여본 적이 있는지가 궁금합니다.
간단하게 weak를 사용해서 강한 순환 참조를 없애본 적은 있고, 프로젝트는 아니지만 autoreleasepool을 이용해서 이 retain과 release의 위치가 메소드의 시작과 끝이라는 점을 학습을 하고, 이거를 직접 확인해 보고 싶어서 UIImage를 직접 load를 해보면서 메모리 사용량을 비교해 본 적이 있습니다. 
그래서 autoreleasepool을 사용을 안 했을 때는 말씀드린 것처럼 메모리가 종료될 때까지 꾸준하게 메모리 사용량이 늘었지만, autoreleasepool을 사용을 했을 때는 이 autoreleasepool의 코드 블록이 끝날 때마다 메모리가 해제가 되어서 메모리 총 사용량이 감소된 결과를 볼 수 있었습니다.

### Q19. 그러면 그 메모리가 해제되었다는 거를 알 수 있는 방법이 어떤 게 있을까요?
저는 간단하게 확인을 하고 싶어서 Xcode의 인스트러먼츠를 사용을 했는데, 조금 더 상세하게 보고 싶다면 XCTest의 XCMetric을 사용을 해서 메모리를 측정을 할 수 있습니다.

### Q20. 델리게이트 패턴이라는 게 있는데요 이거를 어떻게 사용하는지 설명해 주실 수 있나요?
델리게이트 패턴은 메서드 구현을 다른 곳에 위임하는 패턴입니다. 
그래서 하나의 정해진 메소드 구현이 아니라 호출하는 상황에 따라 메서드 동작을 변경해 주고 싶을 때 델리게이트 사용이 유용합니다. 
iOS에서는 프로토콜을 사용해서 델리게이트를 구현을 할 수 있고, 이 델리게이트로 연결된 객체가 참조 객체라면, weak 키워드를 이용해서 강한 순환 참조를 끊어야 하는 주의점이 있습니다. 그래서 일대일로 데이터를 전달할 때나 이렇게 호출하는 쪽에서 메서드를 구현하고 싶을 때 딜리게이트를 사용을 하면 유용하게 사용할 수 있습니다.

### Q21. 혹시 그 딜리게이트 패턴 사용하시면서 느꼈던 단점이 있으셨을까요?
가장 크게 느낀 단점은 구현해야 하는 코드의 양이 많다는 점이 좀 단점으로 느껴졌습니다. 
왜냐하면 이거를 이 딜리게이트를 채택하는 곳마다 이 메서드 구현부를 직접 작성해줘야 되기 때문에 작성해갖고 하는 코드가 많다는 단점을 느꼈어요.

### Q22. 단점을 해소하려면 어떻게 하는 게 좋을까요?
프로토콜의 기본 구현을 사용을 해서 직접 구현하지 않아도 뭔가 공통된 로직이 있다면 그런 것들은 프로토콜을 익스텐션해서 기본 구현을 하는 방향으로 개선할 수 있을 것 같습니다.

### Q23. 그걸 개선할 수 있는 아예 다른 패턴이나 혹시 다른 방식들에 대해서도 알고 계신지 궁금합니다.
딜리게이트의 데이터 전달 쪽을 개선하려면 콤바인 같은 거를 이용해서 데이터 바인딩을 해주거나, 1대 1이 아니라 1대 n의 방식도 괜찮다면 노티피케이션 센터를 사용하는 것도 좋은 방법인 것 같습니다.

### Q24. 델리게이트 패턴을 쓸 때 주의해야 할 점에 대해서 알고 계신가요?
델리게이트는 객체와 객체 사이를 연결해 주기 때문에 강한 순환 참조가 발생할 수 있습니다. 
그래서 weak 키워드를 이용을 해서 강한 순환 참조를 끊어야 합니다.

### Q25. 아까 설명을 하실 때 NotificationCenter를 잠깐 얘기를 하셨던 것 같은데, 이거에 관련해서도 간단하게 이야기해 주실 수 있을까요?
네 Notification은 iOS에서 이벤트를 주고받을 수 있는 방법 중 하나입니다. 
그래서 Notification의 이름과 수행할 메서드 그다음에 오브젝트를 설정할 수 있고 이 Notification을 보내면 이 이벤트를 구독하고 있는 곳에서 메소드를 수행을 할 수가 있습니다. 
그래서 Notification의 가장 큰 장점은 Notification을 보내는 곳과 받는 곳에 의존성이 존재하지 않기 때문에 그런 객체 간 의존성을 줄일 수 있다는 장점이 있고 단점으로는 1대 n이기 때문에 어디에서 보냈는지 어떤 타이밍에 이벤트가 올지 모르기 때문에 이벤트 흐름을 파악하기 어렵다는 단점이 있습니다.

### Q26. 그럼 실제 어떤 경우에 NotificationCenter를 써야 할까요?
NotificationCenter는 연결이 필요 연결을 연결을 하지 않으면서 뭔가 데이터 전달을 하고 싶거나 이벤트를 수신하고 싶을 때 사용하면 유용합니다. 그래서 iOS에서는 시스템 이벤트 예를 들어 화면이 돌아갔을 때나 화면이 백그라운드로 갔을 때 이런 식으로 시스템에서 노티피케이션을 많이 보내기도 합니다.

### Q27. 그러면 실제로 프로젝트를 하시면서 Notification를 활용해서 이점을 얻으셨던 경험이 있으신가요?
최근에 Combine을 사용을 했는데 Notification이 콤바인도 지원을 해주면서 텍스트 필드에 textDidChanged 이벤트를 이렇게 AnyPublisher로 반환을 할 수가 있더라고요. 
그래서 이렇게 텍스트 필드가 텍스트 뷰가 변했을 때 이 변화를 감지하기 위해서 노티피케이션 센터를 사용한 경험이 있습니다.

### Q28. Notification은 동기적으로 흘러갈까요 아니면 비동기적으로 수행을 하나요?
이벤트를 보낼 때 동기적으로 수행이 되기 때문에 모든 이벤트를 수신한 뒤에야 이제 보낸 곳에서 이벤트 처리가 가능합니다. 
그래서 만약 보내는 수가 많다면 이때 타이밍을 잘 조절을 해야 합니다.

### Q29. 그럼 비동기적으로는 수행할 수 없을까요?
내부적으로 queue를 만들어서 Notification을 커스텀 해주면 비동기적으로도 수행을 할 수 있습니다.
