- 자기소개 부탁드립니다.
  - 안녕하십니까. 이번에 지원하게된 이준복이라고 합니다. iOS 개발자를 이제 하고 싶어서 지원을 하게 되었고요. iOS 공부를 하게 된 계기는 이제 대학교 졸업 작품에서 처음으로 접하게 되었는데 그때 흥미를 느껴서 이제 iOS 개발자를 원하게 되었고 그때 당시에는 iOS를 처음 공부하면서 개발을 하다 보니까 이제 스토리보드나 이런식으로 짜고 이제 Swift 문법도 하나도 모르던 상태에서 개발을 진행하다 보니까 기본적인 문법이나 아니면 뷰의 라이프 사이클 같은 아주 기본적인 내용을 몰라서 앱이 죽어버리는 경우가 많더라고요. 그리고 스토리보드로 짜다 보니까 좀 이제 확장을 문어발식으로 ㅎ다ㅏ보니까 나중에 한 코드를 수정하기 위해서는 정말 여러 코드를 봐야 하고 또 스토리보드도 많이 고쳐야 되는 그런 문제점이 있어서 내가 iOS 개발자를 하기 위해서는 공부를 좀 더 해야겠다라는 생각을 가져서 이제 졸업 작품이 다 끝난 뒤에 iOS 문법만을 가르쳐주는 온라인 부트 캠프가 있었습니다. 두달 동안 진행하는 거였는데 이제 그거를 듣게 되었고 그거를 듣게 된 이유는 이제 Swift 문법도 공부를 하기 위해서도 있지만 졸업 작품으로 진행하면서 공식 문서를 읽는데 문법을 몰라서 적용을 못하는 경우가 종종 있었습니다. 그래서 내가 만약에 iOS 개발자를 하게 된다면 최소한 Swift 문법은 모르는 문법이 없어야 이제 개발 공부를 시작 할 수 있다고 생각을 해서 가장 기초적인 걸 먼저 끝내고자 이제 부트 캠프를 듣게 되었고 그때 당시에 들었던 내용들 덕분에 이제 그전과는 다르게 공식 문서 같은걸 읽었을 떄 문법때문에 모르는 경우는 없을 정도로 많은 공부를 하였고요. 그렇게 문법을 끝내고 나서 이제 스토리보드만 코드를 짯는데 이제 코드로만 UI를 짜거나 이제 그렇게 개발하는 방식이 있다는 것을 알게되어 그것을 공부하고 있던 와중에 이제 네이버 부스트 캠프나 이런 실력을 향상하기 위한 다양한 강의들을 듣고 취업을 준비하던
   와중에 회사에 지원하게 되었습니다.

- 옵셔널에 대해서 설명해주세요.
  - 옵셔널은 Swift 문법 중 가장 큰 특징이 있는 문법 중에 하나라고 생각을 하는데요. 이제 보통 다른 문법에서는 이제 값이 없거나 그런 거를 NULL이라는 거를 처리를 해서 접근하게 되면 이제 없는 공백이니까 죽어가게 되는데 Swift에서는 이제 그런 앱이 그냥 죽는 경우를 방지를 하고자 어떤 방법이 있을까 고민을 하다가 나온 것이 옵셔널인 것으로 알고 있습니다. 옵셔널은 이제 값을 감싸서 이 값을 접근하기 전에 얘가 정말 비었는지 안 비었는지 먼저 체크를 하고 비면 이제 앱이 죽지 않게 처리를 해주는 것인데 옵셔널은 내부적으로 some과 none이라는 스위치 문으로 작성이 되어있습니다. 그래서 연관값을 가지고 이제 옵셔널을 해제를 할 수가 있는데요. 옵셔널에서 이제 어,,, 네 옵셔널은 그런데 그런 뭐라고 설명을 해야 될까요? 옵셔널 ,,, 옵셔널은 그래서 기본 문법이랑 이제 물음표를 붙이게 되면 옵셔널로 만들 수 있습니다.

- 옵셔널 내부가 스위치문으로 되어있다고 하셨는데 옵셔널 내부에 있는 프로즌이라는 단어를 혹시 알고 계신가요 ?
  - 아니요 모르고 있습니다. 그리고 옵셔널이 스위치문이라고 말씀을 드렸는데 스위치문이 아니라 enum형식입니다. 제가 착각을 하고 잘못 말했습니다.

- 그럼 만약에 옵셔널이 값이 없는 것을 표현한다고 말씀하셨는데 그러면 혹시 언래핑 방식에 대해서 설명해 줄 수 있나요 ?
  - 언래핑 방식은 이제 제가 알고 있기로는 세가지로 알고 있습니다. guard let 구문, if let 구문 그 다음에 옵셔널 강제 해제로 이렇게 알고 있는데 옵셔널을 이제 사용을 하기 위해서 아까 말씀드렸다시피 이제 껍질로 감싸고 있다고 말씀을 드리지 않았습니까 ? 그래서 그 안에 있는 값을 사용하기 위해선 이 껍질을 벗겨줘야 하는데 그거를 이제 guard let 구문으로 이제 옵셔널을 해제 해주거나 마찬가지로 if let 구문으로 옵셔널 해제를 해주거나 아니면 안에 값이 있던지 없던지 무조건 해제를 하겠다라는 강제 옵셔널 해제 방법 이렇게 세가지가 있습니다.

- 그러면 guard let과 if let을 말씀해주셨는데 이 둘의 차이는 뭘까요 ?
  - 제가 느끼기에는 이제 guard let 같은 경우에는 이제 그 구문만이 아니라 전체적인 함수 내에서 사용을 하기 위해서 그러니까 블록이 가장 큰 블록에서 사용을 하기 위해서는 guard let 을 사용하는 것 같고 이제 if let 같은 경우에는 이 값이 없으면 크게 지장은 없지만 이제 다음 구문이 그냥 없으면 없는대로 다음 구문을 실행해도 무방한 때에 if let을 사용하는 것 같습니다. guard let은 이제 이 값이 없으면 다음 구문은 실행되지 말아야할때 사용하고 반대로 if let은 이 값이 없어서 블록내에 구문이 실행이 안되도 다음 구문은 실행되지만 값이 있다면 이제 어느 구문을 실행하라고 할때 사용하는 것 같습니다.

- 클로저가 혹시 어떤 것인지 알고 계신가요 ?
  - 클로저는 이제 이름이 없는 함수라고 알고 있는데요 그 이름이 없는 함수라는 게 한 번 사용하고 만다라는 것으로 저는 이해를 하고 있습니다. 그래서 클로저 같은 경우에는 어쨌든 일단은 함수이기 때문에 Swift에서 이제 1급 객체로 사용 가능합니다.

- 1급 객체라고 말씀하셨는데 1급 객체도 한번 설명 부탁드릴게요.
  - 1급 객체라고 한다면 이제 매개 변수나 리턴 값 이런 식으로 사용이 가능하다는 의미로 알고 있습니다. 예를 들어서 이제 Value나 함수 같은 걸 작성을 할 때 매개 변수로 Int 형식을 받고 Int 값을 반환한다든지 이런 식으로 클로저도 마찬가지로 이제 인자로 받을 수 있고 리턴 값으로 줄 수 있는 이런 것들을 1급 객체라고 하는 것으로 알고 있습니다.

- 클로저는 값을 참조하나요 아니면 복사를 하게 되나요?
  - 그거는 이제 그때그때마다 다른데 클로저가 이제 실행이 됐을 때 클로저 캡처를 하게 되면 복사가 되고 이제 그냥 클로저를 사용하게 되면 이제 참조로 하는 것으로 알고 있습니다.

- 탈출 클로저에 대해서 설명 부탁드립니다.
  - 이스케이핑 클로저 같은 경우에는 이 클로저가 이제 이름이 없다 보니까 이 클로저가 실행이 되기 전에 먼저 그 클로저를 받았던 함수가 이제 없어지게 돼버리는 거죠. 그래서 이 클로저 함수가 이제 실행이 안 되는 상황이 있는데 이거를 이제 이 친구가 없어도 이 함수는 나중에 실행이 될 수 있게 해주는 것이 이스케이핑 클로저인 것으로 알고 있습니다.

-  클로저가 옵셔널로 돼서 하면은 그것도 이스케이핑이 가능하다는 걸 혹시 알고 계신가요?
   -  아니요 이거는 몰랐습니다.

- 그러면 이 이스케이핑 클로저는 보통 어떨 때 사용이 되나요?
  - 보통은 이제 제 경험상 비동기 처리나 네트워크 처리를 할 때 많이 사용하게 되었습니다. 비동기나 네트워크 처리를 하게 되면 좀 시간이 오래 걸리기 때문에 그 결과값을 가지고 처리를 해줘야 하는데 그게 동기 방식으로 진행이 되면 이제 그 코드를 기다리면서 계속 이제 메인 작업을 할 수 없기 때문에 비동기 처리를 하는데 근데 그러다 보니까 이제 리턴 값을 받지 못하게 되는 경우가 생겨버린 거죠.  그래서 이때를 위해서 이제 이스케이핑 클로저를 받아서 리턴 값이 나왔을 때 이제 이스케이핑 클로저에 던져줘서 나중에 그 로직을 실행할 수 는 식으로 이런 식으로 사용을 했습니다.

- 그럼 혹시 이 탈출 클로저를 사용을 할 때 약간 좀 주의해야 될 점이 있을까요? 아까 비동기 할 때 하셨다고 했는데 주의해야 될 점이 있을까요?
  - 제가 느꼈을 때 주의해야 할 점은 우선은 그 값을 캡처를 할 때 이제 가장 중요했던 것 같습니다. 이스케이핑 클로저가 받았을 때 그 내부에서 만약에 참조하는 값이 있었다 하면은 나는 이제 클로저는 살아있는데 그 값을 참조했을 때 여기가 죽어서 없는 경우가 생겨버려서 그럴 때 좀 주의를 해야 했고 그다음에 마찬가지로 그런 맥락에서 보자면 셀프 키워드로 이용해서 이제 내 레퍼런스 프로퍼티나 이제 함수를 접근했을 때 주의했어야 했습니다.

- 잠시 레퍼런스 참조에 대한 말씀하셨는데 혹시 arc에 대해서도 설명 한번 부탁드려도 될까요?
  - 스위프트는 이제 ARC를 채용을 하고 있는데요. 이게 이제 파일 시점에 이 컴파일러가 그냥 자동적으로 이제 적절한 시점에 리테인과 릴리즈 함수를 집어넣어줘서 자동으로 카운팅 해주는 것입니다. 보통은 이제 사용자가 직접 이제 리테인이나 릴리즈를 삽입을 해서 참조 카운팅을 했는데 그러다 보니까 메모리 누수가 아무래도 사람이 직접 하다 보니까 메모리 누수 실수나 이런 것들로 인해서 메모리 누수가 발생하는 경우가 잦아서 ARC를 채택하고 있습니다.

- 그러면 이 자동으로 해주니까 자동으로 참조에 대한 카운팅을 다 해주니까 iOS 개발자는 이거에 대해서 그냥 사용만 하면 되는 건가요?
  - 아닙니다. 자동적으로 참조를 해주기 때문에 생기는 문제가 있는데요. 그거는 이제 수동 MRC도 마찬가지겠지만 자동적으로 참조를 하다 보니까 순환 참조를 하게 되는 경우가 있습니다. 방금 말씀드린 이스케이핑 클로저처럼 이제 이스케이핑 클로저를 받는 객체가 있다고 했을 때 이 객체는 이 클로저를 참조를 하고 이 클로저는 반대로 셀프 키워드로 이 객체를 참조를 하게 된다면 둘이 이제 레퍼런스 카운트를 가지고 있기 때문에 둘이 해소가 안 돼서 다른 곳에서는 아무 데서도 참조를 안 하는데 서로 참조를 하고 있기 때문에 이제 컴파일러는 메모리가 이제 계속 참조하고 있다는 것을 알고 있기 때문에 메모리에서 해제를 안 해서 이제 메모리 누수가 발생하기 때문에 ARC를 사용하게 되면 그런 레퍼런스 환영 대기가 발생하지 않도록 주의를 해야 합니다.

- 그러면은 레퍼런스 그러니까 메모리 누수가 발생하지 않기 위해 그러니까 강한 순환 천조가 일어나지 않기 위해서는 ios 개발자는 어떤 것을 해야 되나요? 해결할 수 있는 방법이 있나요?
  - 대표적으로 키워드가 두 가지인데 Weak와 Unowned 키워드를 사용할 수 있습니다. 그래서 둘 다 이제 레퍼런스 카운팅을 해주지 않는 것인데요. Weak와 Unowned 키워드를 붙이게 되면 레퍼런스 카운트가 증가하지 않게 됩니다. 그래서 강한 순환 참조를 방지할 수 있는데 이제 Weak 키워드 같은 경우에는 옵셔널 옵셔널로 처리를 해주기 때문에 이제 접근을 하기 위해서 옵셔널을 해제를 해주거나 아니면 옵셔널 상태로 옵셔널 체이닝을 통해서 그냥 사용을 해줄 수가 있고 Unowned 키워드는 이제 포인트와 같은 느낌으로 사용하게 됩니다. 말 그대로 주소 값만 가지고 있기 때문에 이제 Unowned 같은 경우에는 옵셔널로 처리가 안 돼 있다 보니까 거기에 접근을 하게 되면 정말 메모리가 없어가지고 이제 에러가 발생할 수 있는 확률이 있습니다. 그래서 그것도 따로 에러 처리를 해줘야 합니다.

- 그러면 Weak와 Unowned 둘 중에 어떤 거를 더 선호하고 사용을 하시나요?
  -  저는 대부분 Weak를 사용하고 있습니다. 둘 다 이제 접근하려는 메모리가 살아있는지를 체크를 해야 하는데 이제 Unowned 같은 경우에는 정말 주소 값을 직접 참조를 하다 보니까 아무래도 이제 신경을 써야 할 게 옵셔널보다 좀 더 많다라고 생각을 했고 Weak 키워드 같은 경우에는 단순하게 그냥 옵셔널만 해지해 주면 안전하게 접근이 가능하다고 생각을 해서 이제 Weak 키워드를 더 많이 사용하고 있습니다.
  
- 그러면 Unowned는는 없어도 되는 건가요?
  - 그건 아니라고 생각을 하는데 제가 아직까지는 마땅하게 Weak 키워드와 이제 Unowned는는 키워드 둘 중에 이제 번갈아가면서 사용해 본 적이 없어서 아직까지 Unowned는는드의 필요성을 못 느끼고 있는데 제가 알기로는 듣기로는 이제 Unowned는는 키워드는 주소 값에 직접 접근을 해야 할 경우가 있다라고 들어서 그때 사용하면 유용하다라고 듣긴 했는데 아직까지 좋은 예시나 아니면 활용하는 방법을 찾지 못해서 잘 모르겠습니다.

- 델리게이트 패턴에 대해서 한번 설명 부탁드릴게요.
  - 델리게이트 패턴은 제가 실생활에서도 많이 이제 예시로 들어줄 수 있는데 예를 들어서 저희가 카페를 갔다고 했을 때 주문을 하게 되지 않습니까? 그래서 이제 주문을 하게 되면 직원한테 이제 메뉴를 말하면 직원이 이제 그 커피를 만들어준다는 것을 저희는 알고 있는데 저희가 커피가 어떻게 만들어지는지는 모르지 않습니까? 마찬가지로 델리게이트 패턴은 나는 그 사람이 그 위임받는 객체가 어떤 일은 하는지 알고 있지만 어떻게 하는지는 모르는 상태인 거죠. 그래서 나는 그냥 이거를 이거 해줘라고 부탁만 해주면 이제 그 위임받은 객체가 그 내용을 실행을 하게 되는 그런 패턴입니다.

- iOS에서 델리게이트를 사용하고 있는 것들 예시를 몇 개 들어주실 수 있나요?
  - 대표적으로 UITableViewDelegate와 마찬가지로 UICollectionViewDelegate가 있습니다. 대표적으로 셀을 선택하거나 아니면 셀을 선택하지 않았을 때 셀을 터치했을 때 등등 많은 델리게이트 함수가 있습니다.

- 델리게이트에서는 뭐 크게 여쭤볼 게 없네요. 일단 그럼 노티피케이션 넘어가죠. 노티피케이션이 뭔가요? 
  - 노티피케이션 센터는 제가 알기로는 이제 알림으로 알고 있는데 마찬가지로 델리게이트의 패턴과 좀 유사한 부분이 있다고 생각을 합니다. 그래서 내가 어떤 일을 끝냈을 때 이제 알려주면 그 메시지가 전달받은 곳에서 이제 이 사람이 끝났네 하고 체크를 한 다음에 다음 작업을 할 수 있게 도와주는 게 노티피케이션이라고 생각을 하는데 노티피케이션은 델리게이트 패턴이 만약에 1대 1 관계처럼 이렇게 누구 하나와 이제 상호작용하는 관계라면 노티피케이션은 이 일대 다수의 경우에 사용하기 적합하다라고 생각됩니다. 하나의 메시지를 보내면 다른 곳으로 다 뿌려줄 수가 있기 때문에 옵저버 패턴이라고 부르기도 합니다.

- 그러면은 델리게이트랑 노티피케이션 비슷하다고 하셨는데 노티피케이션은 1 대 4로 하신다고 하셨잖아요 그러면은 델리게이트는 굳이 필요 없는 거 아닌가요? 노티피케이션으로 1대 1로 해버리면 되니까 ?
  - 그거는 이제 좀 다르다고 생각을 하는데 노티피케이션에서 일대일도 물론 가능합니다. 메시지를 하나만 수신을 하게 되면 이제 한 명만 받게 되면 1대 1도 가능하지만 노티피케이션은 아무래도 이제 메시지를 보내고 이제 노티피피케이션 센터에서 다시 메시지를 뿌리는 과정에 있는 시간과 비용이 있지만 델리게이트 같은 경우에는 1대 1이 된다면 그냥 내가 작업이 끝났을 때 바로 직접적으로 호출을 할 수 있기 때문에 노티피케이션보다는 이제 값이나 시간이 조금 더 절약할 수 있다는 장점이 있습니다.


# 피드백

## 전체적인 느낌
- 자기소개가 너무 긴것 같다 1분 내외로 끝내면 좋을 것 같습니다.
- 이제라는 말을 자주 사용하는 것을 확인.
- 내용이 틀리진 않았는데 그렇다고 맞는 것도 아닌 어중간한 대답들이 대부분인 것 같습니다.

## 몰랏던 것
- 옵셔널 이스케이핑
  - https://babbab2.tistory.com/164
- 프로즌
  - https://chibest.tistory.com/99

## 기억에 남는 질문
- delegate에서 AnyObject를 채택하는 이유는 무엇인가 ?
    - delegate를 채택하여 구현하는 곳과 delegate를 호출하는 곳에서의 강한 순환참조를 막기 위해 weak 키워드를 사용해야하는데 이 때문에 AnyObject를 채택해주어야 하지만 이는 참조 타입일 때만 발생하는 문제이기 때문에 delegate를 구현하는 곳이 참조타입이냐 아니냐에 따라 달라질 수 있을 것 같다.

## 다시 답변한다면 ?
- 옵셔널에 대해서 설명해주세요.
  - 변수를 선언을 할때 임시값을 넣는다는 개념이라고 할 수 있습니다. 기존의 타입은 어떤 메모리 주소에 해당타입이 들어있다라고 알려주는 것인데 a라는 Int타입의 변수를 선언을 하고 초기화를 해주지 않았을때 CPU에서 코드를 읽다가 a에 접근을 하게되면 a의 메모리 주소에 값이 없기 때문에 에러가 발생하여 프로그램이 죽게되는 문제가 있었습니다. Swift에서는 이를 해결하기 위해 옵셔널이라는 타입을 만들었습니다. 옵셔널 타입은 메모리 공간을 할당받을때 초기화를 해주지 않아도 임시값을 넣어주어 실제 값이 없음을 포장지로 한번 감싸주는 개념입니다.


- 그러면 guard let과 if let을 말씀해주셨는데 이 둘의 차이는 뭘까요 ?
  - guard let은 옵셔널타입의 변수가 언래핑을 하지 못한다면 그 다음 코드는 실행될 필요가 없을 때 사용하고 if let은 옵셔널 타입의 변수가 언래핑이 가능할때 추가로 블록안에 있는 코드를 실행할 필요가 있거나 변수의 언래핑여부와 상관없이 다음 코드를 실행해야할 때 사용하는 것 같습니다.
