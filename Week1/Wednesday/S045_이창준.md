## Optional

### Q1. Optional이 뭔지 설명해주세요.
네 옵셔널은 이제 값이 없을 수 있을 때 그 타입을 안전하게 쓰기 위해서 있는 일종의 타입이고요.  
옵셔널 같은 경우에는 내부적으로 일단 enum 타입으로 구성이 되어 있어서 some과 none이었나요? 이름은 잘 기억이 안 나는데 nil일 때 쓰는 none 케이스가 있습니다.  
그래서 nil인 경우와 nil이 아닌 경우에 분리하기 위해서 있는 타입이고요.  
이게 안전하게 타입을 사용하기 위해 있는 타입이기 때문에 실제로 사용할 때는 옵셔널을 걷어내고 사용해야 할 때가 많습니다.

### Q2. nil이랑 nil이 아닌 거로 나눈 게 왜 타입 안정성을 높여주는지 설명해 주실 수 있으신가요?
네 제일 대표적인 예로 Dictionary를 사용할 때가 있는데요.  
딕셔너리에 키 값을 넣었을 때 해당 키값에 해당 값이 없는 경우에는 값을 내줄 수가 없는데 그때 옵셔널이 없으면 에러가 발생해서 앱이 터지게 되겠죠 근데 옵셔널이 있으면 앱이 터지는 것까지는 아니고 옵셔널 타입으로 반환을 해줄 수가 있기 때문에 안정성을 보장해 주는 걸로 알고 있습니다.

### Q3. 옵셔널이 enum으로 구현되어 있다는 거는 어떻게 아신 건가요?
사실은 블로그들을 살펴보다가 알게 됐고요.  
그 사실을 안 이후에 이제 실제로 직접 옵셔널 값을 주고 점을 찍어보니까 자동 완성에 none과 some이 있더라고요.

### Q4. 실제로 프로젝트를 진행하시면서 옵셔널을 사용해서 안정성을 높이신 경험이 있는지 궁금합니다.
제일 자주 사용하는 경우는 이제 클래스나 스트럭트 안에 어떤 값을 집어넣어야 되는데 해당 값이 있을 수도 있고 없을 수도 있을 때가 있습니다.  
인스턴스가 생성될 당시에는 없을 수 있는 값들이 있는데 해당 값들을 이후에 주입해 줘야 할 때 옵셔널을 사용하면 안전하게 처리를 할 수 있었습니다.

> Feedback
> 앞에서 Dictionary를 이야기 했으니 다시 한 번 해당 경우를 대답했어도 좋았을 것 같다.


## 클로저
### Q5. 클로저가 뭔지 설명해주세요.
클로저는 일단 기본적으로 코드를 뭉쳐놓은 뭉텅이라고 생각을 하고요.
클로저에는 일단 이름이 있는 클로저가 있고 없는 클로저가 있는데 있는 클로저가 보통 일반적으로 함수라고 부르는 기능이고요.  
없는 경우가 이제 일반적으로 클로저라고 부르는 네인드 클로저로 알고 있습니다.  
그래서 함수와 클로저 둘 다 파라미터로 넣거나 반환을 하거나 타입으로 사용할 수 있습니다.

### Q6. 혹시 왜 전달할 수 있는지도 같이 설명해 주실 수 있으신가요? 간단하게
1급 객체라서로 알고 있습니다.

### Q7. 클로저를 사용할 때 주의해야 할 부분이 있을까요?
클로저를 사용할 때 제일 주의할 사항은 외부의 값을 참조할 때라고 생각하는데요.  
외부에 있는 값을 클로저에서 참조를 하고 있을 때 외부 인스턴스가 해제가 되면 서로 강한 참조가 일어나서 메모리에서 해제가 안 되는 현상이 일어나는 걸로 알고 있습니다.

### Q8. 그러면 그 현상은 어떻게 해결할 수 있을까요?
그 현상 같은 경우에는 이제 weak self를 사용해서 약한 참조로 레퍼런스 참조를 하면 해결할 수 있습니다.

### Q9. 구조체 안에서 클로저를 사용한다고 했을 때 그때는 weak self를 사용해야 할까요?
클로저 내부에서 참조를 할 경우에는 이크 셀프를 사용하지 않으면 무조건 레퍼런스 타입으로 참조를 하기 때문에 *(...처음부터 다시)*
클로저 내부에서는 일단 무조건 참조 타입으로 참조를 하기 때문에 구조체건 아니면 클래스건 weak self를 사용해 주는 게 좋고요.  
weak self를 참조하는 이유는 그렇게 참조를 하면 값 타입으로 참조를 하기 때문에 클래스의 경우에는 그대로 주소를 참조를 하지만 값 타입의 경우에는 값을 복사해서 가져오기 때문으로 알고 있습니다.

### Q10. 클로저에서 값을 캡처하는 이유가 뭘까요?
잘 모르겠습니다. 😅

> Feedback
> 클로저 자체적으로도 수행이 가능해야 하기 때문에 블록 안에서 외부 컨텍스트를 사용을 하기 위해 값을 캡처해서 사용을 합니다.

### Q11. 클로저를 보통 어디서 많이 사용하셨나요?
다른 인스턴스 사이에서 어떤 하나의 인스턴스로 어떤 행동을 전달을 해주고 싶은데 그런 경우에 많이 사용을 했던 것 같습니다.  
그런 경우에는 일반적인 값을 갖고 있는 변수를 전달하면 행동까지는 하지 못하잖아요.
그래서 어떤 동작 자체를 전달하고 싶을 때 자주 사용했던 것 같습니다.


## ARC

### Q12. ARC에 대해서 설명해 주시겠어요?
arc는 이제 Automatic Reference Count의 약자인데요.  
어떤 값을 참조를 할 때 자동으로 레퍼런스 카운트를 증가시키거나 감소시켜주는 역할을 합니다.

### Q13. 레퍼런스 카운트가 뭔가요?
레퍼런스 칸운트는 이제 어떤 참조 타입을 참조를 하면은 해당 값에 대한 참조를 하고 있다는 걸 알고 있어야 되기 때문에 증가시켜주는 걸로 알고 있고요.  
이 레퍼런스 카운트가 0이 되면 메모리에서 해제가 되는 걸로 알고 있습니다.

### Q14. ARC와 관련된 참조 방식 세 가지를 설명해주세요.
강한 참조 같은 경우에는 일반적으로 참조를 할 때 일어나는 참조 방식이고요.  
무조건적으로 레퍼런스 카운트를 1 증가시키기 때문에 두 개의 인스턴스가 서로를 참조하면 두 인스턴스의 rc가 모두 0이 될 수 없기 때문에 사용할 때 주의가 조금 필요합니다.
그리고 weak 같은 경우에는 약한 참조인데요, 
레퍼런스 카운트를 증가를 시키는데 인스턴스가 해제되면 그 인스턴스를 참조하고 있는 인스턴스도 rc를 같이 떨어뜨려서 안전하게 사용할 수 있습니다.
unowned는 이제 rc를 증가시키지 않기는 한데 어떤 인스턴스가 해제된다고 해서 rc를 함께 떨어뜨리지는 않기 때문에 메모리에 상주하고 있을 가능성이 있는 걸로 알고 있습니다.

### Q15. weak랑 unowned의 차이가 뭘까요?
모르겠습니다.

> Feedback
> 사실 이미 답변을 한 내용인데 한 번 더 질문이 들어와서 머리 속이 꼬였습니다.
> 당황하지 않고 알고 있는 내용 다시 한 번 전달하기...

### Q16. ARC는 컴파일 타임이랑 런타임 둘 중에 언제 확인을 하는지 알고 계신가요?
arc 같은 경우에는 컴파일 타임에 일어납니다.  
mrc 방식의 방식을 그대로 사용하는데 arc 같은 경우에는 참조가 될 때와 해제될 때 이제 코드를 직접 삽입해서 컴파일을 하는 걸로 알고 있습니다.

### Q17. 레퍼런스 카운트 자체가 인스턴스다 보니까 실행을 해야만 알 수 있다고 생각을 하는데 이걸 어떻게 컴파일 시점에 파악을 할 수 있을까요?
이 부분까지는 잘 모르겠습니다.

> Feedback
> 실제로 컴파일 타임에 계속 리테인 릴리즈라는 코드를 계속 삽입해서 확인을 합니다.

## Delegate

### Q18. delegate에 대해서 설명해 주세요.
delegate 같은 경우에는 데이터를 전달하는 하나의 패턴인데요.  
어떤 하나의 인스턴스에서 다른 인스턴스로 값을 전달할 때 사용하는 패턴입니다.
근데 그 값을 전달하는 방식이 하나의 인스턴스를 위임자로 채택을 해서 말 그대로 위임을 동작 자체를 위임을 합니다.

### Q19. delegate를 사용해보신 적이 있으신가요?
가장 보기 쉬운 예시로는 이제 UIKit에서 기본적으로 제공되는 컴포넌트들의 델리게이트를 사용하는 경우가 있고요.  
직접 delegate를 만들어서 사용하는 경우는 보통 어떤 커스텀 뷰에서 다른 뷰나 ViewController로 동작을 위임할 때 사용을 했었습니다.

### Q20. iOS에서는 프로토콜을 어떻게 구현을 할 수가 있나요?
프로토콜을 일단 메서드와 함께 구현을 하고요.  
AnyObject를 채택을 해서 클래스 인스턴스만 사용을 할 수 있도록 제한을 해준 다음에 둘 간의 강한 연결이 일어나지 않도록 weak를 이용해서 delegate 인스턴스를 생성해서 다른 인스턴스에서 그 인스턴스를 사용하는 것으로 사용합니다.

### Q21. delegate 말고 또 데이터 전달을 하는 다른 것들은 뭐가 있을까요?
두 가지 방법이 일단 생각이 나는데요.  
하나는 클로저를 사용을 해서 동작 자체를 파라미터로 넣어서 전달을 하는 경우가 있을 것 같고요.  
다른 하나는 NotificationCenter를 사용하는 방법이 있을 것 같습니다.

### Q22. 어떤 경우에 delegate를 사용하시고 어떤 경우에 클로저를 사용하시나요?
저 같은 경우에는 이제 delegate는 보통 경우가 조금 많을 때 사용을 하는 편인 것 같습니다.  
프로토콜 하나로 이제 어떤 뷰에서 위임을 해야 하는 동작들을 묶어주는 기능도 할 수 있다고 생각하기 때문에 delegate 같은 경우에는 위임할 동작이 많을 때 사용을 하는 것 같고요.  
클로저 같은 경우에는 단발적으로 동작을 전달을 해야 할 때 주로 사용하는 것 같습니다.

## NotificationCenter

### Q23. NotificationCenter에 대해 설명해주세요.
NotificationCenter 같은 경우도 이제 데이터를 전달할 때 사용하는 방법 중에 하나이고요.  
Publisher와 Subscriber의 개념을 사용하는 방식입니다.  
Key 값이라는 상수 값을 사용해서 매칭을 하는 방식으로 알고 있습니다.

### Q24. NotificationCenter의 장점이 뭘까요?
퍼블리셔와 구독의 형태이기 때문에 1 대 1의 형태가 아니라 1대 n의 형태로도 사용이 가능하고요.  
그 다음에 직접 참조하기 어려울 것 같은 인스턴스들 사이에서 값을 전달할 때도 유용하다고 알고 있습니다.

### Q25. 그렇다면 단점은 어떤 점이 있을까요?
단점의 경우에는 제 생각에는 데이터의 흐름이 명확하게 코드상으로 나타나지 않는다는 점인 것 같고요.  
그 다음에 이제 시스템 자체적으로 사용하는 오티피케이션 센터도 많기 때문에 정말 우연의 일치로 키 값이 동일하다거나 하는 경우가 있다고 들었습니다.

### Q26. Notification을 직접 사용해보신 적은 없나요?
사실 NotificationCenter 같은 경우에는 데이터의 흐름 파악 자체가 어렵기 때문에 정말 데이터 전달 방식이 떠오르지 않을 때 잠깐 임시적으로 사용을 했다가 이후에 1순위로 변경하는 코드 중에 하나인 것 같습니다.

### Q27. NotificationCenter를 써야 한다면 제약 사항이나 유의사항으로 어떤 점들을 고려를 해야 할까요?
일단 Key 값을 베이스로 작동을 하기 때문에 unique한 Key 값을 사용해야 하고요.  
그 다음에 object 파라미터를 통해서 어떤 인스턴스에서 오는 값만 받을 지를 필터링도 할 수 있기 때문에 object 기능을 적극적으로 활용하면 어느 정도 단점을 극복할 수 있을 것 같습니다.

## 자체 피드백
- "그 다음에", "것 같습니다", "근데 / 그런데", "고요"
	- 알고 있는 내용은 확실하게 전달하자.
- 스스로의 페이스에 너무 말리는 편이다. 심장을 단단하게 단련하자..
