## Q&A

### Q1. 옵셔널에 대해서 뭔지 설명해 주실 수 있을까요?
옵셔널은 일단 스위프트에서 제공하는 타입으로 그 값이 있을 수도 있고 없을 수도 있다는 타입을 의미하고 있습니다.

### Q2. 그러면 옵셔널은 왜 사용을 할까요?
예를 들어서 네트워킹을 할 때를 예를 들으면 서버로부터 받는 데이터가 데이터가 없을 수도 있기 때문에 그러한 경우를 대비해서 안전하게 데이터를 추출하기 위해서 사용하는 것으로 알고 있습니다.

### Q3. 안전하게 추출하신다는 말씀을 하셨는데 그러면 옵셔널에서 값을 추출하는 방법을 설명해 주실 수 있으실까요?
네 그 값을 추출하는 방법이 옵셔널 바인딩이랑 옵셔널 언래핑 이렇게 있는 것으로 알고 있는데 저는 옵셔널 바인딩을 주로 많이 사용해서 안전하게 옵셔널을 해제를 해줬고 옵셔널 언래핑은 부득이한 경우가 아니고서 잘 안 사용했던 것 같습니다.

### Q4. 그러면 강제 언래핑은 왜 사용을 안 하셨나요?
강제 업래핑을 하면 옵셔널에 이제 값이 없게 되면 에러를 발생시키기 때문에 그러한 부분에서 예외 처리가 불가능하기 때문에 강제 래핑을 지양하려고 했습니다.

### Q5. 강제 언래핑이 이점을 가지는 경우도 있을까요?
네. 예를 들어서 이제 뷰 컨트롤러에서 스토리보드로 구현하게 되면  뷰 컨트롤러에서 ib 아웃렛으로 뷰 컴포넌트를 가지고 있게 되는데 그 경우에 강제 언래핑을 시켜줘서 뷰 컨트롤러가 해당 뷰 컴포넌트를 무조건 가지고 있어야 된다라는 의미로 만약에 갖고 있지 않으면 에러를 발생시켜서 아예 실행이 되지 않도록 하는 경우가 있는 것 같습니다.

### Q6. 그러면 강제 업래핑을 하게 되면 실행이 안 되게 하는 경우가 있다고 하는데 근데 앱이 죽는 것보다는 값이 없어서 뷰가 안 나오는 게 더 좋은 거라고 생각하지 않으신가요? 이거에 대해서 어떻게 생각하시나요?
제가 생각하기로는 결국은 앱은 어떤 기능을 지원하기 위해서 있는 건데 그 기능을 지원하지 못하면 차라리 앱이 죽는 것이 더 좋은 것 같다고 생각합니다.


### Q7. 옵셔널 내부는 어떻게 되어 있는지 알고 계신가요?
내부는 열거형으로 none과 some으로 구별이 되어 있는 걸로 알고 있습니다.

### Q8. 그러면 스위프트 언어에서 이제 또 enum으로 선언되어 있는 것들은 어떤 것이 있을까요?
예를 들어서 정확히 맞는지는 잘 모르겠는데 그 Int 타입의 zero라든지 아니면 max 이런 값이 열거형 되어 있지 않나 생각합니다.

### Q9. 옵셔널 바인딩을 하는 방법 중에 두 가지가 있잖아요 그 두 가지에 대해서 설명을 해 주시고 어떤 기준으로 선택을 하시는지도 같이 얘기해 주시면 감사할 것 같아요.
일단 if let을 쓰는 방법이 첫 번째로 있고, guard let을 사용하는 방법이 있는데 if let은 주로 이프렛을 사용하게 되면 스코프가 한 단계 더 생겨서 스코프 내부에서 값을 사용할 때 if let을 사용하는 것 같고, guard let은 조기 탈출 느낌으로 옵셔널 바인딩이 안되었을 때 이후에 구문이 실행되지 못하게 그 구문을 탈추시켜서 좀 더 코드를 줄이거나 아니면 코드의 depth을 한 단계 낮추는 역할로 많이 사용하고 있습니다.

### Q10. 스위프트 언어의 특징이 뭐라고 생각하시나요?
프로토콜과 제네릭을 손꼽고 싶습니다.

### Q11. 만약에 변수 a b가 있는데 a는 인트형이고 b는 인트 옵셔널이라고 했을 때 a의 b 값이 들어갈 수가 있나요?
안 들어갈 것 같습니다.

### Q12. 그렇다면 그 반대는 가능할까요?
네. 반대는 가능합니다.

### Q13. 클로저에 대해서 간략히 설명해 주세요.
클로저는 일단 실행 가능한 코드 블록을 클로저라고 생각합니다.
그래서 보통 이름이 있는 클로저를 함수라고 하고 이름이 없는 것을 이제 클로저라고 하는 것 같습니다.

### Q14. 그러면 클로저는 어떤 상황에서 사용을 할까요? 그냥 메서드만 사용하면 되는데 왜 익명 함수를 사용을 할까요?
1급 함수로서 함수를 인자로 받거나 아니면 리턴 값으로 함수를 전달하기 위해서 클로저를 사용하는 것으로 알고 있습니다

### Q15. 그러면 아니면 클로저는 그 스니프트에서 객체로 취급할 수가 있을까요?
네 취급할 수 있습니다.

### Q16. 객체로 취급할 수 있다는 게 무슨 뜻인지 설명해 주실 수 있으실까요?
예를 들어서 클로저를 변수에 할당할 수 있다는 것을 의미한다고 생각합니다.

### Q17. 클로저를 사용을 할 때 주의해야 할 점이 있을까요?
네. 클로저를 사용해서 외부 객체를 참조하게 되면 순환 참조가 발생할 수 있기 때문에 관리를 해줘야 됩니다. 
메모리 레퍼런스를 weak self를 통해서 관리해 순환 참조를 방지해야 됩니다.

### Q18. 그러면 강한 참조는 어떤 이유 때문에 생긴다고 생각하시나요?
강한 참조는 그 메모리에 올라간 객체들끼리 서로 참조했을 때 생긴다고 생각합니다.

### Q19. 그러면 클로저에서 강한 참조가 발생하는 이유를 방금 답변하신 거랑 약간 연관지어서 다시 설명해 주실 수 있으실까요?
클로저 내부에서 외부에 있는 객체를 참조를 하게 되면 레퍼런스 카운트가 증가를 하게 되는데 그게 증가를 하다가 언제 종료되는 시점을 알지 못해서 레퍼런스 카운트가 계속 증가하는 상황이 생겨서 순환 참조가 발생하는 것 같습니다.

### Q20. 순환 참조가 발생하게 되려면 둘 다 힙에 올라가야 하잖아요. 그러면 방금 답변하신 거랑 연관지어서 생각해 볼 수 있다면 클로저는 어디에 할당이 되나요?
힙에 할당되는 것 같습니다.

### Q21. 혹시 클로저의 조건은 무엇인지 설명해 주실 수 있으실까요? 아니면 클로저를 언제 사용할 수 있는지에 대해서 설명해주세요
제가 주로 사용했던 클로저는 이스케이핑 클로저를 통해서 네트워크 통신을 완료하고 난 뒤에 클로저 블록을 통해 원하는 원하는 로직을 수행하기 위해서 사용했던 것 같습니다.

### Q22. 스위프트에서 제공해 주는 대표적인 클로저들이 몇 개 있잖아요. 간단하게 몇 개 있는 지 한번 나열해주실 수 있나요?
고차함수의 forEach, filter, reduce가 있는 것 같습니다.

### Q23. 트레일링 클로저에 대해서 혹시 알고 계신가요?
자세하게는 모르는 것 같습니다.

### Q24. ARC가 뭔지 설명해 주실 수 있으신가요?
ARC는 오토 레퍼런스 카운터의 약자로 레퍼런스 카운트를 자동으로 카운팅해주면 해주고 이제 카운터가 0이 됐을 때 메모리에서 해제시켜주는 메모리 관리를 도와주는 도구입니다.

### Q25. 그렇다면 자동으로 카운팅을 이제 레퍼런스 카운팅을 올려주고 낮춰준다고 하셨는데 그러면 그 레퍼런스 카운팅을 증가해 주고 감소시켜주는 타이밍은 언제인가요?
컴파일 시점에 되는 것으로 알고 있습니다.

### Q26. 그러면 가비지 컬렉터에 대해서 아시나요?
잘 모르겠습니다.

### Q27. ARC는 레퍼런스 카운트를 개발자가 직접 건드릴 일이 없잖아요. 그러면 개발자는 메모리 관리에 관해서 신경을 아예 안 써도 될까요? 아니면 ARC를 사용함으로 인해 생기는 문제가 있을까요?
ARC를 지원한다고 하더라도 그 레퍼런스 카운트가 0이 되지 않는 서로 강한 참조로 엮여져 있어서 레퍼런스 카운트가 0이 되지 않는 경우가 있어 메모리에 해제가 안 되는 경우도 있기 때문에 개발자가 직접 관리를 해줘야 된다고 생각합니다.

### Q28. ARC 관점에서 구조체랑 클래스 성능 차이를 간단하게만 비교해 봐주실 수 있으실까요? 그 이전에 구조체는 ARC가 적용이 될까요?
구조체는 값 타입이기 때문에 ARC에 적용을 안 받을 것 같습니다.

### Q29. 그러면 스위프트가 클래스보다는 구조체를 권장하는 이유에 대해서 이거랑 연관을 지어서 한번 말을 해봐주실 수 있으실까요?
아까 질문해 주셨던 것처럼 arc 관점에서 구조체는 값 타입이기 때문에 메모리에 올라가는 시점이 값이 변경 됐을 때 메모리에 올라가니까 클래스보다 메모리 관리 측면에서는 좀 더 좋을 것 같습니다.

### Q30. Delegate 패턴에 대해서 간략히 설명해 주세요.
Delegate 패턴이 이제 객체와 객체 간의 소통을 위해서 사용하는 패턴인데 Delegate라는 말 자체가 위임하다라는 뜻이어서 그 어떤 객체가 구현해야 할 메소드를 다른 객체에게 위임을 해서 데이터를 전달하거나 어떤 이벤트가 발생했을 때 이벤트 발생을 전달하는 그런 패턴으로 알고 있습니다.

### Q31. 그러면 Delegate 패턴을 사용해보신 적이 있나요?
예를 들어서 화면과 화면 간의 이벤트 전달에서 예를 들어 a라는 뷰 컨트롤러가 있고 b라는 뷰 컨트롤러가 있으면 a에서 b로 이동을 하고 b에서 a로 이동했을 때의 이벤트를 a에게 전달해 주기 위해서 Delegate를 이용해서 뷰 컨트롤러가 b의 Delegate를 채택해서 이벤트를 감지하는 그런 로직을 구현해 봤었습니다.

### Q32. 네 방금 설명하신 점과 이제 UIKit에서 델리게이트를 자주 사용하는 이유를 방금 설명하신 점과 연결해서 이야기해 주실 수 있을까요?
UIKit에서는 보통 테이블 뷰 아니면 컬렉션 뷰에서 델리게이트 패턴을 위해서 많이 구현을 했었는데 아무래도 델리게이트라는 게 어떠한 객체에서 발생한 이벤트를 다른 객체에서 처리를 하도록 하는 패턴이다 보니까 뷰와 뷰 간 통신에서 원하는 곳에서 실행시킬 수 있게 로직을 구현할 때 사용하는 것 같습니다.

### Q33. 그러면 스위프트에서 대표적으로 델리게이트 패턴을 사용하는 예시를 몇 가지만 들어주실 수 있으실까요?
예를 들어 테이블 뷰에서 그 테이블 뷰에서 구현에 필요한 메소드들을 뷰 컨트롤러가 테이블 뷰에 딜리게이트를 채택해서 테이블 뷰와 뷰 컨트롤러 간의 의존성을 분리시켜서 테이블 뷰는 뷰 컨트롤러의 존재를 모르지만 뷰 컨트롤러는 테이블 뷰에 원하는 로직을 시행할 수 있도록 하고 있는 것 같습니다.

### Q34. 노티피케이션에 대해서 간략히 설명해 주세요.
노티피케이션은 이전에 말씀드렸던 델리게이트 패턴과 다르게 1대 n의 구독 형태로 이루어져 있고 이벤트를 방출시켜서 이벤트를 이제 노티피케이션 센터로 보내면 특정한 모티피케이션을 구독하고 있는 구독자들에게 이벤트가 발생했다고 알려주거나 아니면 특정 데이터를 전달하는 그런 역할을 수행하고 있습니다.

### Q35. 노티피케이션을 썼을 때의 장점과 단점을 설명해 주실 수 있으신가요?
장점은 일단 노티피케이션 1대다의 구조이기 때문에 하나의 발생한 이벤트를 여러 객체한테 이벤트가 발생했다는 걸 전달해서 어떤 로직을 처리해야 될 때 되게 간편했고 단점은 결국엔 어떠한 객체든지 이 해당 노티피케이션 옵저버를 노티피케이션을 구독을 하기만 하면 어디서 구독만 하면 어떤 객체든지 이벤트를 전달받을 수 있다는 단점이 있을 것 같습니다.

### Q36. 어떤 객체든지 이벤트를 받을 수 있다는 게 어떻게 단점으로 작용을 할까요?
데이터의 흐름이 어디서 어디까지 전달되었는지 그런 거를 체크하기가 개발자 입장에서는 힘들 것 같습니다.

## 자체 피드백
- 전체적으로 답변에 너무 자신감이 없었고 명확하게 답변을 하지 않고 `~인 것 같다.`, `~로 알고 있다.` 이런식으로 답변한 것이 좀 아쉽다.
- 질문의 요지를 잘 파악하지 못하고 횡설수설하게 대답한 느낌이다.
- 확실히 학습이 좀 더 필요한 느낌이다. 아는 내용이 적다보니 꼬리 질문에 대해 답하기 어려웠다.
- 애매하게 알고 있거나 모르는 내용에 대해서는 괜히 아는척 말하려하지말고 모른다고 확실하게 말을 해야될 것 같다.
