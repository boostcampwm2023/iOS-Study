
### Q1. final 키워드를 쓰면은 왜 메모리를 적게 잡을까요?
원래 클래스 같은 경우에는 메서드들이 어떤 게 있는지 상속관계를 따라서 하나하나 런타임에 살펴보게 되는데,
final을 앞에 붙이면 상속 관계가 없어지기 때문에 컴파일 타임에 어떤 클래스가 어떤 메서드를 가지고 있는지 구현체를 알 수 있게 돼서 이점이 생깁니다.

### Q2. 메모리가 컴파일 타임이랑 런타임 시점이라고 말씀해 주셨는데, 그러면 dynamic 디스패처와 static 디스패처를 알고 계실까요?
파이널이 없을 때 다이나믹 디스패처를 사용하는 것으로 알고 있고요.
다이나믹 디스패처 같은 경우에는 구현체를 확실하게 알고 있지 못한 경우에 런타임에 그걸 알 수 있게 해주는 방법이고
스태틱 디스패처 같은 경우에는 구현체를 확실하게 알고 있는 상황에서 컴파일 타임에 메서드에 대한 정보를 알 수 있는 것이라고 알고 있습니다.

### Q3. initializer는 struct와 class 모두에서 사용할 수 있는데, deinit은 struct에서도 사용할 수 있나요?
사용할 수 없습니다.

### Q4. 동적 디스패처에서 말씀해주셨는데, 클래스랑 프로토콜은 각각 어떤 테이블을 사용하시는지 알고 계실까요?
클래스는 v테이블이라는 것을 사용하는 것으로 알고 있고요.  
프로토콜은 모르겠습니다.

### Q5. mutating 키워드를 붙이는 이유는 뭘까요?
원래 mutating 키워드 같은 경우에는 구조체에서 보통 사용을 하게 되는데요.  
구조체는 값 타입이기 때문에 어떤 값을 변경을 하려면 새로운 인스턴스를 만들어서 값을 변경해야 합니다.  
그렇기 때문에 구조체는 원래는 immutable한 값이고요.  
그것을 전에 설명드린 방식대로 값을 변경하기 위해서 mutating 키워드를 사용해야 하는 것으로 알고 있습니다.

### Q6. 프로토콜의 extension에서 어디까지 구현을 할 수가 있나요?
프로토콜의 익스텐션에서는 연산 프로퍼티와 그다음에 함수 메서드의 구현체를 구현할 수 있습니다.

### Q7. 멀티스레드로 동작하는 앱을 만들고 싶으면 어떤 방식이 있을까요?
일단 디스패치 큐를 사용을 할 수 있을 것 같고요.  
그다음에 이제 async/await도 사용을 할 수는 있는데 이 경우에는 이제 쓰레드를 저희가 원하는 대로 지정을 해 줄 수는 없기 때문에 멀티 스레딩이 가능하다 정도로 사용할 수 있을 것 같습니다.

### Q8. 메인 스레드와 글로벌 스레드의 차이를 아시나요?
메인 스레드 같은 경우에는 이제 앱에서 필수적으로 사용을 하는 스레드입니다.
그리고 보통 메인 스레드에서 ui 작업이 이루어집니다. 보통이 아니고 무조건 이루어집니다.
그리고 글로벌 스레드 같은 경우에는 메인 스레드 외에 이제 필요한 작업들을 수행하는 스레드고요.  
메인스레드와 별개로 다른 동시적으로 수행해야 하는 작업들이 있을 때 사용하는 스레드입니다.

### Q9. UI 작업을 왜 메인 스레드에서만 해야 할까요?
설명을 못하겠습니다. 

### Q10. 구조체에서 쓸 수 있는 생성자랑 클래스에서 쓸 수 있는 생성자의 개수는 동일할까요?
어.. 잘 모르겠습니다.

### Q11. 클래스에서 생성자의 종류가 4 가지가 있는 거 알고 계신가요?
세 가지는 알고 있습니다.
하나는 지정 생성자로 이제 필수적으로 하나 필요한 생성자가 있고요.  
그다음에 편의 생성자가 있는데 편의 생성자 같은 경우에는 지정 생성자를 사용하되 조금 더 편하게 생성자를 사용할 수 있도록 만들어주는 생성자입니다.
마지막 하나는 required 생성자가 있는데 이거는 언제 쓰는지 까먹었습니다.

> Feedback
> 생성자 다 까먹었다.. 다시 공부하기

### Q12. 편의 생성자랑 방금 말씀해 주신 required 생성자랑 지정 생성자 전부 다 구조체에서 사용 가능한가요?
구도체에서는 지정 생성자만 사용 가능한 걸로 알고 있습니다.

### Q13. 구조체와 클래스에서 지정 생성자를 구현을 해주지 않을 수가 있을까요?
구조체의 경우에는 별도의 생성자를 설정해주지 않아도 멤버와이즈 생성자가 자동으로 생성되어서 생성자를 사용할 수 있습니다.
클래스는 자동으로 구현해 주지 않는 걸로 알고 있습니다.

### Q14. 동기 비동기 방식을 완전 아무 관련 지식이 없는 분한테 설명을 해준다고 한다면 어떻게 설명해 주실 수 있으실까요?
제 친구가 있으면은 친구한테 뭘 사달라고 부탁을 합니다.  
그리고 사달라고 부탁을 한 후에 친구가 올 때까지 마냥 기다리는 게 이제 동기 방식이고요.  
비동기 방식은 친구가 어떤 물건을 사러 간 사이에 본인은 이제 다른 일을 할 수 있는 것이 비동기입니다.

### Q15. 직렬과 병렬도 초등학생에게 설명해 준다고 생각을 하시고 설명해 주실 수 있으실까요?
직렬의 경우에는 한 줄서기라고 볼 수 있습니다.  
그래서 한 줄로 들어갈 수 있는 터널에 들어가서 한 명 한 명 순차적으로 나가는 것으로 비유를 할 수 있을 것 같고요.  
병렬 같은 경우에는 이제 한 줄 서기가 아니라 여러 줄 서기라서 터널 여러 개를 사람들이 나눠서 통과한다라고 설명할 수 있을 것 같습니다.

### Q16. Concurrency의 Task에 대해서 알고 계신가요?
async/await의 경우에는 최종적으로 어딘가에서는 동기적으로 처리가 되어야 하는데 그런 동기적인 처리를 하기 위한 코드 묶음을 Task로 사용을 합니다.

### Q17. GCD에 디스패치 큐의 종류가 몇 개인지는 알고 계실까요?
디스패치큐는 이제 메인이 있고 글로벌이 있고 그다음에 이제 커스텀 디스패치 큐가 있습니다.

### Q18. 각각이 Serial인지 Concurrent인지 알고 계실까요?
메인 스레드 같은 경우에는 단일 쓰레드이기 때문에 직렬로 사용을 하고요.  
글로벌 같은 경우에는 병렬을 사용하는 걸로 알고 있습니다.

### Q19. Queue의 관점에서 볼 때 직렬일 때 비동기로 주는 것과 동기로 주는 것에 큰 차이가 있을까요?
동기 작업을 실행을 하면은 해당 동기 작업이 끝날 때까지 아무것도 할 수 없기 때문에 작업을 아예 멈춰 있는 상태가 되고요.  
직렬 스레드에서 이제 비동기 함수를 실행을 할 경우에는 해당 작업을 시킨 후에 본인의 일로 다시 돌아가기 때문에 화면이 멈추는 경우는 없는 걸로 알고 있습니다.

> Feedback
> 뭐라는 걸까... ㅎ;;

### Q20. 말씀만 들어보면 sync가 필요가 없어 보이는데 sync가 있는 이유에 대해서 자신만의 생각을 말씀해 주실 수 있으실까요?
싱크의 경우에는 작업을 시킨 후에 그 작업의 결과가 필요할 때 사용한다고 생각합니다.

> Feedback
> 싱크를 하게 되면 하고 있던 작업이 멈춘다고 하셨잖아요.
> 그러면은 그냥 싱크를 쓰지 않고 계속 써내려가는 것과 별 차이가 없는 것 같아요
> -> 그러게요..?


## 학습 내용

### 생성자

과거 정리 복습...
https://nomatterjun.github.io/post/Allen%2F2022-10-03-Allen26

필수 생성자 (required init)
- 하위 클래스가 지정 생성자를 정의하면, 하위 클래스는 **상위 클래스의 필수 생성자를 무조건 구현**해야함

실패 가능 생성자 (init?)
- `init?`은 다른 `init?`를 호출할 수 없다.
- `init?`은 `init`을 호출할 수 있다.
- `init`은 `init?`을 호출할 수 없다.
- 상위 `init?`를 하위에서 `init`으로 재정의 가능
- 상위 `init`을 하위에서 `init?`으로 재정의는 불가능

### Main Queue와 sync
Main Queue는 **Serial Queue**이다.
- 하나의 Task가 끝나야 다음 Task를 실행한다.
	- Queue를 block하고, 다른 Task의 진입을 차단한다.
- 일반적인 경우, `DispatchQueue.main.sync { }`는 deadlock을 유발하여 앱이 크래시 되게 한다.
	- 여기서 일반적인 경우 = Main Thread에서 호출하는 경우

`main.sync`는 그럼 대체 언제 쓰는가?
- Global Queue 안에서 UI 작업이 필요하면 보통 `main.async { }`를 사용한다.
- 하지만 이런 작업은 보통 클로저 내부의 동작에 순서가 상관 없을 때의 이야기다.
```swift
DispatchQueue.global(qos: .default).async {
	DispatchQueue.main.async {
		print("First")
	}

	print("1")

	DispatchQueue.main.async {
		sleep(2)
		print("Second")

	}

	print("2")

	DispatchQueue.main.async {
		print("Third")
	}

	print("3")

}
```

위 코드는

> 1, 2, 3, First, Second, Third

를 출력합니다.
그런데 1이 출력된 후에 Second가 출력되고 싶다면...?
그런데 이 출력이 사실은 그냥 출력이 아니라 UI 업데이트라면..?

이럴 때 `main.sync`를 사용할 수 있습니다.

```swift
DispatchQueue.global(qos: .default).async {
	DispatchQueue.main.sync {
		print("First")
	}

	print("1")

	DispatchQueue.main.sync {
		sleep(2)
		print("Second")

	}

	print("2")

	DispatchQueue.main.sync {
		print("Third")
	}

	print("3")

}
```

이 코드는

> First, 1, (... 2s ...) , Second, 2, Third, 3

의 순서대로 출력합니다.
여기서 print가 아니라
`progressView.setProgress(0.5, animated: true)`와 같은 UI 작업이 들아간다면,
하나의 Global Queue 클로저 내부에서 순서를 보장한 채로 UI를 업데이트 해줄 수 있습니다!
