# Q&A

### qos에서 백그라운드는 어떨 때 사용하나요 ?
제가 알기로는 제가 사용했을 때는 이미지나 아니면 당장에 실행될 필요가 없을 때 백그라운드에서 실행을 했습니다. 근데 그렇다고 qos를 준다고 해서 이제 우선순위가 있긴 하지만 그걸 완벽하게 보장해주지는 않는 것으로 알고 있습니다.

### DispatchQueue에 대해서 간단하게 설명해 주세요.
디스패치큐는 이제 애플에 있는 프레임워크 중 하나인데 동기나 이제 비동기 같은 테스크 작업 단위를 이제 나눠서 동작하기 위해서 만들어진 것으로 알고 있습니다. 그래서 이제 DispatchQueue에에는 총 세 가지가 있는데 메인 큐와 글로벌 큐 이제 프라이빗으로 커스텀으로 만들 수 있는 큐 이렇게 세 가지로 있는 것으로 알고 있습니다. 그래서 디스패치 메인에서는 이제 ui 관련된 코드들을 넣어줘야 하는 것으로 이제 ui 관련 코드는 무조건 메인 큐에서 동작하게 만들어 놓았습니다.

### Struct는 무엇이고 어떻게 사용을 하나요 ?
스트럭트는 이제 클래스와 같이 설명을 드리자면 예를 들어서 저희 지금 3명이 있는데 이제 3명도 다 같이 동시에 가지고 있는 것들이 있지 않습니까? 예를 들어서 이름이나 나이, 성별 이런 것들이 있는데 이런 것들을 이제 그때그때마다 변수를 선언해줘서 이제 계속 만들다 보니까 이거를 한 번으로 합쳐서 카테고리화를 시킬 수 있을 것 같은데라는 아이디어에서 나온 것인데요. 우리 지금 3명을 예로 들었는데 저희는 사람이라는 카테고리로 엮을 수도 있고 대한민국 국민 이런 식으로 카테고리를 묶을 수 있지 않습니까? 그래서 그런 카테고리로 묶은 다음에 이제 거기에 해당하는 값들만 주면 각각의 다른 객체들이 생성 만들어지니까 이제 컴퓨터도 이런 방식으로 하면 코드의 중복을 많이 줄일 수 있을 것 같다라고 생각을 해서 만들어지게 되었고요. 클래스와  가장 큰 차이점은 일단은 메모리에 어떤 방식으로 저장이 되는지가 가장 큰 차이점인 것 같습니다. 스트럭트 같은 경우에는 이제 콜바이 밸류 형식이라고 해서 이제 값 타입으로 저장이 되고 클래스 같은 경우에는 콜바이 레퍼런스라고 해서 이제 참조 타입으로 메모리에 저장이 되고요. 그다음 두 번째로 가장 큰 차이점은 이제 상속이 가능하냐 불가능하냐의 차이로 알고 있습니다.

### 데지그네이티드 생성자(Designated init)에 대해 설명해주세요.
 지정 생성자는 이제 가장 기본적인 생성자인데요. 이제 스트럭트나 클래스에 이제 필연적으로 있는 프로포티나 연산들을 초기화해 주는 생성자입니다. 그래서 컨비니언스 같은 편의 생성자를 이제 호출을 하려면 무조건 지정 생성자를 호출해줘야 합니다. 

 ### 클래스와 스트럭트를 선택할 때 본인만의 기준이 있나요 ?
 일단은 저는 기본적으로 이제 스트럭트로 선택을 하는데 만약에 이제 하나를 생성을 했을 때 여러 군데에서 접근을 하게 된다면 이제 클래스로 바꿔주는 편이고요. 그게 아니라면 이제 그냥 한 군데에서만 접근을 하거나 아니면 데이터를 그냥 넘겨주고 이제 플로우가 이렇게 단방향으로 흐르게 된다면 스트럭트로 사용하고 있습니다.

 ### 인스터스 메서드와 클래스 메서드의 차이점을 아시나요 ?
 클래스 메서드는 이제 컴파일 시점에 코드 영역에서 이제 올라가서 이제 클래스.으로 접근할 수가 있고요. 인스턴스 메소드는 인스턴트를 생성한 변수명.으로 접근 가능한 것으로 알고 있습니다.

 ### 클래스 메소드는 struct나 enum을 사용할 수 있나요 ?
 네 사용 가능합니다. 클래스 메서드지만 이제 타입 메서드라고 저는 말씀하신 걸로 이해하면 될까요? 타임 메서드는 이제 스테틱이나 클래스 키워드를 붙여서 그 타입점으로 전체적으로 접근이 가능하기 때문에 이넘이나 스트럭트 같은 곳에서도 사용 가능합니다
-> 불가능. 답변내에 정답이 있었다. class 키워드가 붙으면 상속받앗을 때 재정의가 가능한것인데 struct와 enum은 상속을 하지 못하기 때문


 ### 익스텐션 내부의 함수를 오버라이드 할 수 있나요 ?
 익스텐션 내부에서 오버라이드 하지 못합니다.
 -> @objc가 붙은 함수는 가능하다

 ### class키워드 앞에 final 키워드를 붙임으로서 얻는 이점이 어떤게 있나요 ?
 가장 큰 이점은 이제 상속이 없다는 것을 컴파일이 알기 때문에 더 이상 이제 메서드가 원래는 클래스 같은 경우에는 컴파일 시점에 결정되는 게 아니라 실행되는 함수가 이제 런타임 시점에 결정이 되는데 파이널 키워드를 붙임으로써 이제 상속의 가능성이 없어지다 보니까 어떤 함수를 실행할 수 있는지 이제 오버라이드가 아닌 이상은 컴파일 시점에 결정이 되기 때문에 실행 시간에 이점이 있는 것으로 알고 있습니다.

 ### .키워드에 대해 설명해 주세요
 접근 연산자로서 이제 점 연산자는 그 내부에 있는 타입의 안에 있는 프로퍼티나 이제 메서드의 접근이 가능합니다. 그래서 프라이빗이나 되어 있는 그 파일의 상태 접근 제어자를 어떻게 붙였느냐에 따라서 이제 접근 가능한 것들이 있고 접근 불가능한 것들이 있습니다.

 ### 제네릭에 대해 설명해주세요
 제네릭은 이제 제 언어로 이제 설명을 드리자면 저희가 일단은 타입이 다 다른데 plus라는 함수를 만들고 싶습니다.  그러면은 매개 변수로 이제 Int를 받게 되면 Int를 리턴해주는 plus 함수를 만들었는데 이제 그게 같은 로직이지만 만약에 타입이 Double 형식이나 아니면 다른 형식이 오게 된다면 그 함수 내부에는 있는 로직은 똑같은데 이제 타입이 다름으로써 함수를 계속 작성해야 되는 이제 코드가 중복되는 문제가 있었습니다. 그래서 이거를 해결해 주기 위해서 이게 동일한 로직인데 그냥 타입만 바꾸면 완전 같은 코드니까 이걸 어떻게 해결할 수 있을까라는 아이디어에서 나온 게 제네릭인데요. 제네릭은 이제 타입을 받음으로써 그 타입에 맞게 이제 함수를 바꿔주는 역할을 하게 됩니다.  공장 공장이라고 템플릿 다른 언어에서는 템플릿이라고 하는 것으로 알고 있는데 공장이라고 저는 생각을 합니다. 타입에 맞게 가공해주는 공정

 ### Hashable이 뭘까요 ?
 해시는 이제 해싱이 가능한가 아닌가로 알고 있는데 Hashable 내부에 Comparable 이 Equatable을 채택을 해야지 되는 것으로 알고 있습니다. 비교할 수 있나 없나를 먼저 체크를 하고 그다음에 해싱을 할 수 있냐 없냐 네 그것으로 알고 있는데 이거에 대해서는 제가 정확하게는 잘 몰라서 모르겠습니다.
-> Hashable과 Comparable이 Equtable을 상속받고 있는거였음

 ### 프로토콜에서 제너릭을 사용하는 방법을 알고 계신가요? 
 프로토콜에서 제네릭을 사용하기 위해선 어소시에이티드 타입이라는 것을 사용해 이제 사용해서 사용할 수 있습니다.

 ### Hashable에서 Equatable을 채택해야한다고 했는데 왜그럴까요 ??
 잘 모르겠습니다.
 -> https://velog.io/@hayeon/Hashable%EC%9D%B4-%EB%AC%B4%EC%97%87%EC%9D%B4%EA%B3%A0-Equatable%EC%9D%84-%EC%99%9C-%EC%83%81%EC%86%8D%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94%EC%A7%80-%EC%84%A4%EB%AA%85%ED%95%98%EC%8B%9C%EC%98%A4

### hash(into:) 함수에 대해 알고 계신가요 ??
잘 모르겠습니다.
-> https://ios-development.tistory.com/912
