Q1. Struct와 Class와 Enum 차이

- Struct : 값 타입, 상속이 불가능
- Class : 참조 타입, 상속이 가능
- Enum : 값 타입, 연관된 값들을 나타내기 위한 타입으로 상속은 불가능

Q2. Struct와 Class 중에 어떠한 경우에서 해당 타입 채택하는지

- Struct : 데이터의 복사본이 필요할 때, 상속이 필요 없을 때
- Class : 참조 타입이 필요하거나 상속, 런타임에 타입 캐스팅이 필요한 경우

Q3. 값의 변경이 잦을 때 Class를 사용하는 장점

- 실제 데이터가 복사되지 않음

Q4. Struct에 그러면 var를 왜 두는지? 값을 변경 하는데에도 Struct를 왜 씀?

<aside>
🔥

1. **왜 `var`를 사용하는가?**
    - Swift에서 `struct`와 `enum`은 둘 다 값 타입입니다. `var`를 사용하는 이유는 그 인스턴스의 값을 변경할 수 있게 하기 위함입니다. `let`을 사용하면 그 인스턴스의 값이 변경 불가능하게 됩니다.
2. **값 타입 vs 참조 타입**:
    - 값 타입은 예측 가능하고 오류를 줄이는데 도움이 됩니다. 예를 들어, 함수로 값을 전달할 때, 해당 값이 변경될 우려가 없다면 코드를 읽고 이해하기 더 쉽습니다.
    - 참조 타입은 상태가 공유될 수 있으므로 부작용을 유발할 수 있습니다.
3. **성능 상 이점**:
    - Swift의 메모리 관리 및 최적화 기술 중 하나인 **`Copy On Write`** (COW) 덕분에, 구조체의 데이터를 복사할 때 실제 데이터가 복사되는 것이 아니라 참조만 복사됩니다. 실제 데이터 복사는 데이터를 변경할 때만 발생합니다. 따라서 성능 저하가 크게 발생하지 않습니다.
    - 값 타입은 스택 메모리에 저장되는 반면 참조 타입은 힙 메모리에 저장되므로, 값 타입은 메모리 할당 및 해제에 있어서 더 효율적입니다.
    - 참조 카운트 관리, 가비지 컬렉션 등의 오버헤드가 필요 없기 때문에, 간단한 데이터 구조에 대해선 구조체가 더 효율적입니다.
4. **왜 Apple은 `Struct` 사용을 권장하는가?**
    - Swift는 안전하고 예측 가능한 코드 작성을 위해 설계되었습니다. **`Struct`**와 같은 값 타입은 이러한 목표를 지원합니다.
    - 또한, 함수형 프로그래밍 패러다임을 채택하려는 현대의 프로그래밍 경향과도 잘 어울립니다.


5. **왜 `var`를 지원하는가?**
    - 값 타입(`struct`나 `enum` 같은)은 상황에 따라 변경 가능하거나 불변하게 만들 수 있어야 합니다. `var`는 해당 값을 변경 가능하게 만들고, `let`은 불변하게 만듭니다.
    - 때로는 데이터 모델의 특정 속성만 바뀌어야 할 때가 있습니다. 이런 경우에 `var`를 사용하여 해당 속성만 변경하도록 할 수 있습니다.

3. **메모리 측면에서의 영향**:
    - Swift에서 **`struct`**와 **`enum`**은 최적화된 방식으로 메모리를 관리합니다. 위에서 언급했던 **`Copy On Write`** (COW) 기술로 인해, 값 타입의 데이터를 복사할 때마다 실제 데이터가 메모리에 복사되는 것은 아닙니다. 실제 복사는 데이터에 변경이 발생할 때만 이루어집니다.
    - 따라서, **`mutating`** 메소드나 **`var`** 속성을 사용하여 값 타입의 데이터를 변경하더라도, 이는 메모리 사용량이 크게 증가하거나 성능 저하를 일으키는 것은 아닙니다.

결론적으로, Swift는 **`mutating`** 키워드와 **`var`** 속성을 제공하여 개발자에게 유연성을 제공하고, 동시에 내부적인 최적화를 통해 메모리와 성능 측면에서도 효율적으로 동작합니다.



Q5. Class와 Struct의 큰 차이점

- 상속 여부

Q6. Class의 성능을 향상 시킬 수 있는 방법

- 일단은 final이라고 대답했는데 이것 이외에 있는지 모르겠음

Q7. 상속관계 유무를 Runtime에 타입이 정해지나?

- Runtime
    
1. **다형성과 상속**: 클래스는 상속을 통해 다형성을 구현할 수 있습니다. 즉, 부모 클래스 타입의 변수나 상수에 자식 클래스의 인스턴스를 할당할 수 있습니다.

```swift
swiftCopy code
class Animal {}
class Dog: Animal {}

let myDog: Animal = Dog()

```

1. **컴파일 타임 vs 런타임**:
    - **컴파일 타임**: 소스 코드가 컴파일러에 의해 기계어로 변환되는 시점을 의미합니다. 이때 타입 검사, 문법 검사 등이 수행됩니다.
    - **런타임**: 프로그램이 실제로 실행되는 시점을 의미합니다.
2. **타입 결정**:
    - 변수나 상수의 **선언 타입**은 **컴파일 타임**에 결정됩니다. 예를 들어, 위의 **`myDog`** 변수의 선언 타입은 **`Animal`**입니다.
    - 그러나 변수나 상수에 할당된 **실제 인스턴스의 타입**은 **런타임**에 결정될 수 있습니다. 예를 들어, **`myDog`**에 할당된 실제 인스턴스는 **`Dog`**입니다.

Q8. Struct에서 Extension이 가능한가?

- 당근 → 안되는 것 코드로 해보자

Q9. COW 어떤 방식으로 동작하는가?

- COW는 값 타입의 내부 데이터를 수정할 때만 실제 데이터의 복사가 일어남 → 메모리 효율

Q10. COW와 lazy의 차이점

- COW는 메모리 효율성을 위한 측면
- lazy는 프로퍼티의 지연 초기화를 위한 것 → 쓰레드 Safe

Q11. Convenience init은 무엇인가?

- 주요 생성자를 보조하는 역할을 하는 생성자로, 주 생성자에게 초기화를 위임하는 생성자 → 코드

Q12. UserDefault를 사용해본 경험이 있는가?

- 있음

Q13. Protocol에 대해 설명해주세요

- 특정 작업의 기능의 청사진을 정의하는 타입

Q14. Protocol에 서 작성할 수 없는 것과 작성할 수 있는 것

- 작성 가능 : 프로퍼티, 메서드, 연산자, 서브스크립트, 이니셜라이저의 요구사항
- 작성 불가능 : 저장 프로퍼티, 메서드의 구현

Q15. Proocol에서 생성자도 작성이 가능한가?

- 가능은 하지만 구현은 불가 → 코드로 테스트

Q16. QOS와 종류의 설명

- Quality of Service : 작업의 우선 순위를 정할 때 사용
- User-Interaction, User-Initialed, Utility, Background 등

Q17. GCD는 언제 사용을 하는가?

- 병렬작업
- 비동기작업

Q18. GCD와 async/await의 차이점

- GCD는 사용할 때 쓰레드를 생성
- async 키워드는 쓰레드에 대한 제어권을 포기한 상태에서 시스템이 쓰레드 하나를 잡아서 Task를 줌

→ 좀 더 구체적으로 알아봐야할 듯

Q19. DispatchGroup의 역할과 사용용도

- 여러 비동기 작업이 모두 완료될 때까지 대기하게 할 수 있음

Q20. Concurrent와 async의 차이

- Concurrent는 여러 작업이 동시에 실행 될 수 있음을 의미
- async는 작업이 비동기적으로 실행될 것임을 의미

Q21. Extension의 역할과 Extension에서 작성가능한 것과 작성 불가능한 것

- 가능한 것 : 메서드, 계산 프로퍼티, 이니셜라이저, 프로토콜 채택
- 불가능한 것 : 저장 프로퍼티

Q22. Extension에서 생성자와 computed property 를 사용할 수 있는가?

- 그렇다! 모든 init이 동작하는지는 코드로 확인해볼 것

Q23. Protocol에서 get과 set을 갖고있는 프로퍼티를 Extension에서 작성이 가능한가?

- 가능은 하다고 함, 단 계산 프로퍼티일 때 → 코드로 작성해볼 것
